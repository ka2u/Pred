.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Trigger 3pm"
.TH Class::Trigger 3pm "2009-10-12" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Trigger \- Mixin to add / call inheritable triggers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Foo;
\&  use Class::Trigger;
\&
\&  sub foo {
\&      my $self = shift;
\&      $self\->call_trigger(\*(Aqbefore_foo\*(Aq);
\&      # some code ...
\&      $self\->call_trigger(\*(Aqmiddle_of_foo\*(Aq);
\&      # some code ...
\&      $self\->call_trigger(\*(Aqafter_foo\*(Aq);
\&  }
\&
\&  package main;
\&  Foo\->add_trigger(before_foo => \e&sub1);
\&  Foo\->add_trigger(after_foo => \e&sub2);
\&
\&  my $foo = Foo\->new;
\&  $foo\->foo;            # then sub1, sub2 called
\&
\&  # triggers are inheritable
\&  package Bar;
\&  use base qw(Foo);
\&
\&  Bar\->add_trigger(before_foo => \e&sub);
\&
\&  # triggers can be object based
\&  $foo\->add_trigger(after_foo => \e&sub3);
\&  $foo\->foo;            # sub3 would appply only to this object
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Class::Trigger is a mixin class to add / call triggers (or hooks)
that get called at some points you specify.
.SH "METHODS"
.IX Header "METHODS"
By using this module, your class is capable of following methods.
.IP "add_trigger" 4
.IX Item "add_trigger"
.Vb 2
\&  Foo\->add_trigger($triggerpoint => $sub);
\&  $foo\->add_trigger($triggerpoint => $sub);
\&
\&
\&  Foo\->add_trigger( name => $triggerpoint,
\&                    callback => sub {return undef},
\&                    abortable => 1); 
\&
\&  # no further triggers will be called. Undef will be returned.
.Ve
.Sp
Adds triggers for trigger point. You can have any number of triggers
for each point. Each coderef will be passed a reference to the calling object, 
as well as arguments passed in via call_trigger. Return values will be
captured in \fIlist context\fR.
.Sp
If add_trigger is called with named parameters and the \f(CW\*(C`abortable\*(C'\fR
parameter is passed a true value, a false return value from trigger
code will stop processing of this trigger point and return a \f(CW\*(C`false\*(C'\fR
value to the calling code.
.Sp
If \f(CW\*(C`add_trigger\*(C'\fR is called without the \f(CW\*(C`abortable\*(C'\fR flag, return
values will be captured by call_trigger, but failures will be ignored.
.Sp
If \f(CW\*(C`add_trigger\*(C'\fR is called as object method, whole current trigger
table will be copied onto the object and the new trigger added to
that. (The object must be implemented as hash.)
.Sp
.Vb 1
\&  my $foo = Foo\->new;
\&
\&  # this trigger ($sub_foo) would apply only to $foo object
\&  $foo\->add_trigger($triggerpoint => $sub_foo);
\&  $foo\->foo;
\&
\&  # And not to another $bar object
\&  my $bar = Foo\->new;
\&  $bar\->foo;
.Ve
.IP "call_trigger" 4
.IX Item "call_trigger"
.Vb 1
\&  $foo\->call_trigger($triggerpoint, @args);
.Ve
.Sp
Calls triggers for trigger point, which were added via \f(CW\*(C`add_trigger\*(C'\fR
method. Each triggers will be passed a copy of the object as the first argument.
Remaining arguments passed to \f(CW\*(C`call_trigger\*(C'\fR will be passed on to each trigger.
Triggers are invoked in the same order they were defined.
.Sp
If there are no \f(CW\*(C`abortable\*(C'\fR triggers or no \f(CW\*(C`abortable\*(C'\fR trigger point returns 
a false value, \f(CW\*(C`call_trigger\*(C'\fR will return the number of triggers processed.
.Sp
If an \f(CW\*(C`abortable\*(C'\fR trigger returns a false value, call trigger will stop execution
of the trigger point and return undef.
.IP "last_trigger_results" 4
.IX Item "last_trigger_results"
.Vb 1
\&    my @results = @{ $foo\->last_trigger_results };
.Ve
.Sp
Returns a reference to an array of the return values of all triggers called
for the last trigger point. Results are ordered in the same order the triggers
were run.
.SH "TRIGGER POINTS"
.IX Header "TRIGGER POINTS"
By default you can make any number of trigger points, but if you want
to declare names of trigger points explicitly, you can do it via
\&\f(CW\*(C`import\*(C'\fR.
.PP
.Vb 2
\&  package Foo;
\&  use Class::Trigger qw(foo bar baz);
\&
\&  package main;
\&  Foo\->add_trigger(foo  => \e&sub1); # okay
\&  Foo\->add_trigger(hoge => \e&sub2); # exception
.Ve
.SH "FAQ"
.IX Header "FAQ"
\&\fBAcknowledgement:\fR Thanks to everyone at \s-1POOP\s0 mailing-list
(http://poop.sourceforge.net/).
.IP "Q." 4
.IX Item "Q."
This module lets me add subs to be run before/after a specific
subroutine is run.  Yes?
.IP "A." 4
.IX Item "A."
You put various \fIcall_trigger()\fR method in your class.  Then your class
users can call \fIadd_trigger()\fR method to add subs to be run in points
just you specify (exactly where you put \fIcall_trigger()\fR).
.IP "Q." 4
.IX Item "Q."
Are you aware of the perl-aspects project and the Aspect module?  Very
similar to Class::Trigger by the look of it, but its not nearly as
explicit.  Its not necessary for \fIfoo()\fR to actually say \*(L"triggers go
*here*\*(R", you just add them.
.IP "A." 4
.IX Item "A."
Yep ;)
.Sp
But the difference with Aspect would be that Class::Trigger is so
simple that it's easy to learn, and doesn't require 5.6 or over.
.IP "Q." 4
.IX Item "Q."
How does this compare to Sub::Versive, or Hook::LexWrap?
.IP "A." 4
.IX Item "A."
Very similar. But the difference with Class::Trigger would be the
explicitness of trigger points.
.Sp
In addition, you can put hooks in any point, rather than pre or post
of a method.
.IP "Q." 4
.IX Item "Q."
It looks interesting, but I just can't think of a practical example of
its use...
.IP "A." 4
.IX Item "A."
(by Tony Bowden)
.Sp
I originally added code like this to Class::DBI to cope with one
particular case: auto-upkeep of full-text search indices.
.Sp
So I added functionality in Class::DBI to be able to trigger an
arbitary subroutine every time something happened \- then it was a
simple matter of setting up triggers on \s-1INSERT\s0 and \s-1UPDATE\s0 to reindex
that row, and on \s-1DELETE\s0 to remove that index row.
.Sp
See Class::DBI::mysql::FullTextSearch and its source code to see it
in action.
.SH "AUTHORS"
.IX Header "AUTHORS"
Original idea by Tony Bowden <tony@kasei.com> in Class::DBI.
.PP
Code by Tatsuhiko Miyagawa <miyagawa@bulknews.net>.
.PP
Jesse Vincent added a code to get return values from triggers and
abortable flag.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Class::DBI
